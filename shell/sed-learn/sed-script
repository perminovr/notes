#!/bin/bash

# ОСНОВНОЕ	---------------------------------------------------------------------------------------------------------------------------------------

M="
'' - строгие, команды не интерпретируются. нельзя подставить переменную $VAR
"" - можно $VAR

--follow-symlinks - обязателен для работы с симлинками

pattern - буфер с обработанной строкой
hold - пользовательский буфер

синтаксис команды: [addr]X[options]

[addr]=
	nn					-- число
	$					-- последняя строка
	first~step			-- начиная с ервого по шагам
	
	

X=
	a\text				-- append text
	b lbl				-- переход к lbl без условий
	c\text				-- замена строки на text
	d					-- удалить строку
	D					-- работа с pattern: если в нем есть \n, то удаляет все до \n и обрабатывает pattern завного; если \n нет, то как работает d
	e cmd				-- выполнить команду, вывод команды в std
	F					-- печать имени текущего обрабатываемого файла
	g					-- hold -> pattern
	G					-- pattern = pattern + \n + hold
	h					-- pattern -> hold
	H					-- hold = hold + \n +pattern
	i\text				-- insert text
	l					-- 'C-style' print (использовтаь с опцией -n)
	n					-- следующая строка со входа -> pattern
	N					-- прочитать следующую строку, добавить в pattern \n
	p					-- печать найденного по шаблону
	P					-- печать pattern до \n
	q					-- выход
	Q					-- выход без печати
	r file				-- прочитать file
	R file				-- 
	s/pat/repl/[fl]		-- замена по шаблону
		g				-- проход по всем найденным строкам
		число			-- замена в указанной строке
		p				-- печать найденного
		w file	 		-- печать в file
		e				--  
		i				-- не чуствителен регистру
		m				-- мультилайн			
	t lbl				-- переход к lbl если замена выполнена успешно
	T lbl				-- !t
	w file				-- запись результата в файл
	W file				-- запись результата в файл до первого '\n'?
	x					-- swap pattern и hold
	y/src/dst/			-- замена символов один к одному s->d. r->s и т.д.
	z					-- очистить pattern
	#					-- коммент
	{ cmd ; cmd ... }	-- группировка команд. обычно юзается при работе в общем диапазоне 2,3{...}
	= 					-- печать номера строки
	: lbl				-- метка перехода

разделитель внутри команды: ';' = '\n'
команды a, c, e, i, r, R, w, W не могут сопровождаться ';' и должны заканчиваться '\n'

"



# ПРИМЕРЫ	---------------------------------------------------------------------------------------------------------------------------------------

#sed -n 'p' myfile						# = cat myfile
#sed -n '/uu/p' myfile					# = grep uu myfile 
#sed -n '2,2{/uu/p}' myfile				# = grep uu myfile (со 2 по 2 строку)
#sed -n '2!s/uu/gg/p' myfile			# замена всех uu на gg за исключением 2 строки

#sed 's/pat/repl/2' myfile				# замена второго содержимого строки (!) и вывод в поток!
#sed 's/pat\|hhh/repl/g' myfile			# замена pat и hhh на repl
#sed 's/pat/repl/g' myfile				# замена каждого встречного содержимого строки
#sed -n 's/pat/repl/gw out' myfile		# замена каждого встречного содержимого строки (!) и в файл out
#sed -n '/yocto/s/1=2/3=2/p' myfile		# поиск строки по фильтру, замена и вывод в поток!

#sed '4,4d' myfile						# удалить 4 строку
#sed '4,/DATA/d' myfile					# удалить с 4 строки по первую найденную DATA
#sed '/hhh/d' myfile					# удалить по шаблону
#sed '/second/,/fourth/d' myfile		# удалить все строки с 1 шаблона по 2

#sed '/hhh/ a\INSERT' myfile			# вставить после найденного шаблона
#sed '/hhh/ i\INSERT' myfile			# вставить до найденного шаблона
#sed '/hhh/ c\JJJ' myfile				# замена всей строки, найденной по шаблону на JJJ

#sed '/yocto/ y/123/098/' myfile		# замена символов по соответствию 1->0 и тд


# ДОПОЛНИТЕЛЬНО	-----------------------------------------------------------------------------------------------------------------------------------

M="
regex
	строчные/заглавные (GNU)
		\L		-- все строчные
		\l		-- первая строчная
		\U
		\u
		\E		-- завершение L / U

	перечисления
		*			-- 0..m
		\+			-- 1..m
		\?			-- 0 or 1
		\{2\}		-- 2
		\{2,4\}		-- 2..4
		\{2,\}		-- 2..m

	группировка
		\(abc\)*
		
	ИЛИ
		regexp1\|regexp2
		
	И	
		regexp1regexp2
"

# ПРИМЕРЫ	---------------------------------------------------------------------------------------------------------------------------------------

# если путь '/bin/bash' задан в переменной, то использовать:
#sed -n "\#/bin/bash#p" /etc/passwd

# вывод номер строки с шаблоном
#sed -n '/uu/=' myfile								

# & помещает в себя результат, найденный по шаблону
#sed -n 's/pat/&/gp' myfile							

# в файле остануются только строки с заданным шаблоном!
#sed -n -i 's/pat/bar/gp' myfile					

# зацепится к файлу и делает построчное преобразование
#tail -f myfile | sed -n -u -e 's/hhh/III/p' -		

# печать файла до строки, начинающейся с 'foo'
#sed '/^foo/q' input.txt > output.txt				

# каждый 3 символ будет заменен на 'х'
#seq 6 | sed 'n;n;s/./x/'							

# замена DATA на содержимое файла (комент можно)
#sed '/DATA/ {										# comment
#r out
#d}' myfile

# поиск SRC_URI
#sed -n '/^\s*SRC_URI\s*+=\s*\"/,/^\s*[0-9A-Za-z]*\"/s/.*/&/pg' myfile

# 2 не будет выведено 
#seq 3 | sed -n 's/2/X/ ; /[0-9]/p'

# вывод 6-8
#seq 10 | sed -n '6,+2p'

# вывод в обратном порядке
#		
#sed -n '1!G;h;$p'





